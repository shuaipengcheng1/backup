## RabbitMQ 消息队列
学习的前提条件 
java+maven+springboot linux 分布式集群思想

## 什么是MQ
从字面的意思来看 就是消息队列 先入先出 只不过队列中存放的内容是一段消息 


## 为什么使用MQ
1 流量削峰
 例如一个服务器只能接收1万次/s的请求 如果超过了1万次/s 就有可能崩溃
 那么我们就需要使用MQ消息队列进行流量削峰
(在MQ内部会将这些请求分为队列的形式 例如2000,2000,2000,2000... 这样就可以实现流量削峰) 
 缺点 : 请求的速度会降低 因为要排队 但是 总比服务器宕机好

2 应用解耦
  该功能是指一个系统中的功能执行时遇到故障 
  例如一个订单系统执行的时候 将会调用其他的系统执行 如果其中任一个子系统出现了问题 那么整个系统将会无法运作
  但是一旦使用了MQ消息队列后 用户执行了订单系统 即使其中的子系统出现了问题 因为订单系统将请求托付给了MQ消息队列 
也不会阻碍系统下单(该请求会在消息队列中等待 直到系统恢复 这样用户就不会感受到系统故障)


3 异步处理
 有些服务调用的时候是异步的 
传统
A调用了B 当A调用了B 并且B的执行时间未知 那么一般有两种的解决方法 
1 A不停的访问B的查询api 直到完成
2 A提供一个callBack接口 用于B接口完成时调用

例如
A调用了B接口 只需要监听B处理完成的信息 当b处理完成后 会发送一条信息给MQ MQ会将此信息转发给A服务
这样A服务 既不用循环调用B的查询Api 也不用提供接口给B服务调用 这样A服务还能及时的获取消息


## MQ的分类
1 ActiveMQ 最老的MQ 
2 Kafka 卡夫卡 大公司的首选
3 RocketMQ 高并发
4 RabbitMQ 中小型公司

## RabbitMQ的概念
 RabbitMQ是一个消息中间件 他接受并转发消息 你可以把它作为一个快递站
当要发送消息的时候 MQ会接收该消息 并且分发到对应的收件人(PubSub?)

## MQ四大核心
 1 生产着
 2 MQ   
  - 交换机
  - 队列
  - 交换机和队列是一对多的关系 一个交换机对应的是一个或者多个队列
 3 消费者
    

## MQ的安装
先下载erlang语言环境
socat环境
最后安装rabbitmq环境

## 添加自启动
开机自启动
 chkconfig rabbitmq-server on


## rabbitmq的常用的命令
 - 启动mq
/sbin/service rabbitmq-server start
 - 查看mq运行的状态
/sbin/service rabbitmq-server status
 - 关闭mq
/sbin/service rabbitmq-server stop
   
   
## 安装可视化的插件
rabbitmq-plugins enable rabbitmq_management

## 可视化界面
http://192.168.194.128:15672/ 该网址
## 需要创建一个超级用户 来操作RabbitMQ
步骤
 1 查看用户列表
rabbitmqctl list_users
 2 添加一个用户
rabbitmqctl add_user 用户名
 3 设置权限
rabbitmqctl set_user_tags 用户名 administrator


## java代码实现
1 生产者
 1 通过ConnectionFactory 创建链接工厂对象
 2 通过链接工厂对象 配置链接属性 .setUsername .setHost .... 最后 .newConnection 创建链接对象 Connection
 3 通过链接对象 创建信道 .createChannel() 该方法会返回一个Channel
 4 通过信道对象 链接队列
   方法名 channel.queueDeclare() 
 //    参数 (队列名称,是否需要持久化(消息是否持久化 默认存储在运行内存中),该队列是否只供一个消费者消费(如果true就允许 默认为false),是否自动删除,最后一个消费者开链接后 该队列是否自动删除 false为不自动删除,其他参数)
 5 通过信道队列发送信息 channel.basicPublish()
//    参数 (发送到哪一个交换机(字符串) 表示信息要使用的队列的名称,其他参数,消息) 

   



2 消费者
1 通过ConnectionFactory 创建链接工厂对象
2 通过链接工厂对象 配置链接属性 .setUsername .setHost .... 最后 .newConnection 创建链接对象 Connection
3 通过链接对象 创建信道 .createChannel() 该方法会返回一个Channel
4 通过信道对象 链接队列
方法名 channel.queueDeclare()
//    参数 (队列名称,是否需要持久化(消息是否持久化 默认存储在运行内存中),该队列是否只供一个消费者消费(如果true就允许 默认为false),是否自动删除,最后一个消费者开链接后 该队列是否自动删除 false为不自动删除,其他参数)
5 通过信道队列 接收参数
 //        接收参数 (要接收消息的队列名,是否自动答，接收会调用的回调函数，拒绝的回调)
channel.basicConsume(MQ_NAME,true,deliverCallback,cancelCallback);

   

## 错误
(reply-code=530, reply-text=NOT_ALLOWED - access to vhost '/' refused for user 'misaka', class-id=10, method-id=40)
定位发现是连接rabbitmq使用的用户没有赋予访问权限，我创建的是admin用户，给admin用户赋予‘/’目录的访问权限就可以，执行如下命令：
sudo rabbitmqctl  set_permissions -p / admin '.*' '.*' '.*'


## 工作队列的原理
 工作队列 又称任务队列 主要思想是避免立即执行资源密集型任务 而不得不等待它完成
 相反我们安排任务在在之后执行 我们把任务封装为一个消息并将其发送到队列 在后台运行的工作进程将弹出任务并最终执行作业 当有多个工作线程的时候 这些工作的线程将一起处理这些任务
 
**注意**
一个消息只能被处理一次 不可以处理多次
每一个消费者之间的关系 为竞争的关系 如果哪一个消费者枪到了消息 那么其他消费者就不会处理消息了
竞争的解决方法 底层使用的是轮询 也就是一个接一个的接收消息
测试 
类 rabbitCustom 和 rabbitCustom2监听同一个队列 接收为轮询

## 抽取链接工厂类
也就是将链接工厂的链接过程通过一个方法封装并返回


## 消息应答的概念
概念 
 1 消费者完成以恶搞任务可能需要一段的时间 如果其中一个消费者在处理一个较长的任务时突然宕机了 会发生什么呢?
那么就会丢失这一段消息 因为RabbitMQ一旦向消费者发送后 消息将会立刻删除 不会保存在队列中
为了保证消息不会丢失 rabbitmq引入了消息应答机制 消息应答就是 消费者在收到消息并且处理该消息之后 高数rabbitmq它已经经处理了 rabbitmq可以把消息给删除了


消息应答的种类
 1 自动应答
   - 消息一旦发送 就会认为已经成功 这种模式在高吞吐量共和数据传输安全方面做了权衡 
     这种模式下 一旦消费者在处理时宕机 消息就会失效
     
 2 手动应答
  确认方法 : Channel.basicAck()
            RabbitMQ已知道该消息并且成功的处理消息 可以将其删除了
  否定确认 backNack(用于否定确认)
  否定确认 basicReject() 
          与Channel.basicNack少一个参数 
           该方法为不处理消息了 直接拒绝(删除信息在队列中)
  Channel.basicAsk()方法的第二个参数是一个布尔值 
   true  代表批量应答channel上未应答的消息 
   比如或channel 上面有5.6.7.8四条消息 如果为批量应答 那么应答将会应答四条
   false 就只会应答当前对应的消息 其他消息依然不会确认收到消息 继续在队列中等待


## 消息重新入列
例如有两个消费者 四条消息 
消费者1处理消息1 消费者2处理消息2
假如消费者1宕机(未ack) 就会将消息1重新入列 继续排队 等待处理

## 如何开启手动应答
 channel.basicConsume(队列名,false(开启手动应答),成功回调,失败回调)
 答复的放法 
 1 写在成功的回调函数中
                    // 第一个参数为消息标记tag              // 第二个参数为一个布尔值 代表是否开启批量应答
   channel.basicAck(Message.getEnvelope().getDeliveryTag(),false); 


           
## 队列持久化
之前的所有的队列 都是非持久化的 rabbitmq如果重启的化 该队列的就会被删除掉 如果要队列实现持久化
就在声明队列的时候把第二个参数设置为true

channel.queueDeclare(MQ_NAME,true,false,false,null);

设置后 队列即使服务器关闭 还是会存在 因为是存放在磁盘中的

## 消息持久化
消息持久化的开启 需要在basicPublish()的第二个参数写MessageProperties.PERSISTENT_TEST_PLAIN属性 就可以实现消息的持久化


## 不公平分发
默认的情况下 RabbitMQ分发消息采用的是轮询的分发 但是在一些场景下 例如
消费者1 处理消息花了1s 消费者2 花费了5s 这样消费者1就会空闲很长时间
为了比卖你这种情况 可以设置参数 channel.basicQos(1) 也就是设置为不公平分发
channel.basicQos(0) 为轮询分发
该属性在消费者这边设置

## 预取值
 通过设置预取值 可以控制每一条消费者 可以获取到的消息数量
这样就不会出现一个多干一个少干 比如慢的分配了5条 也得做完
 可以设置参数 channel.basicQos(>1的值) 就表示预取值 

## 发布确认
1 设置队列持久化 channel.queueDeclare的第二参数为true
                                                   // 持久化
2 设置消息持久化 设置channel.basicPublish("",队列名,MessageProperties.PERSISTENT_TEXT_PLAIN,要发送的信息。getByte(字符集))

3 发布确认(为了肯定消息持久化)

 开启发布确认的方法
 发布确认默认是没有开启的 如果要开启调用方法confirmSelect 每当你要使用发布确认 都需要在channel上调用方法
 channel.confirmSelect();
确认方法
 channel.waitForConfirms(long)
## 单个确认发布
 每一个消息发布后 马上确认  channel.waitForConfirms(long)

   优点 
  错误好排查
  缺点
   速度非常慢
耗时 3000ms+

## 批量确认
 每n个消息发布后 确认 channel.waitForConfirms(long)
   优点
   速度较快
   缺点
  调试错误麻烦
耗时 171ms

## 异步确认
在消息发布之前 添加一个监听器   channel.addConfirmListener(成功回调,失败回调);
并且使用一个线程安全的同步哈希表 来存储所有的信息 并且如果发送确认成功 就删除对应的消息
如果发送失败 就打印出来

优点
速度较快
错误的消息有对应的下标
耗时 80ms
 

## 交换机的应用
 一旦使用了 交换机 那么这种模式就叫做 发布订阅模式
就算不使用 交换机 也会使用 默认的一个交换机 就是一个 "" 

默认交换机""的绑定
The default exchange is implicitly bound to every queue, with a routing key equal to the queue name. It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted.
默认交换隐式绑定到每个队列，路由密钥等于队列名称。无法显式绑定到默认exchange或从默认exchange取消绑定。它也不能被删除。

也就是 队列名 就是RouterKey值

## 交换机绑定队列
绑定队列
 1绑定对应的队列 通过队列名绑定
 2 一个交换机可以绑定多个队列 通过RoterKey区分

## FanOut
 扇出 : 这种类型非常简单 正如从名称中猜到的那样 他是将接收的所有的消息广播到 （群发）它知道的所有的队列中 
                    // 交换机名 //路由key //是否消息持久化                        //消息    
 channel.basicPublish("FanOut","", MessageProperties.PERSISTENT_TEXT_PLAIN,s.getBytes());

## direct
 该交换机 是通过RouterKey发布消息'

## Topic交换机
该交换机 的路由Key不能随意写 必须满足一定要求 他必须是一个单词列表 以点号隔开 这些单词可以是任意单词
比如说 "stock.usd.nyse" .. 这种单词列表 不能超过255字节
    也就是 "单词.单词.单词 " 单词可以任意字符 并且用.隔开

可以使用替换符
* 可以代替一个单词
# 可以代替零个或多个

例如
 *.orange.*   : 匹配三个单词中 中间为orange的单词列表 
 lazy.# : 匹配lazy开头的 任意长度单词

当一个队列绑定为# 那就是 fanout
当一个队列绑定中没有# * 那就是direct

## 死信的概念
 先从概念上解释这个定义 死信 顾名思义就是无法被消费的信息 字面意思可以这样理解 
一般来说 producer将消息投递到broker中或者直接到queue里了 consumer从queue取出消息进行消费
但一些时候由于特定的原因导致了queue中的某些消息无法被消费 这样的消息如果没有后续的处理 就变成了死信
有死信自然就有了死信队列

应用场景 : 为了保证订单业务的消息数据不丢失 需要使用到RabbitMQ的死信机制 当消息消费发生异常时 将消息投入到死信队列中 
还有比如说 用户在商城下单成功 并点击支付后 在指定时间未支付 那么订单自动失效


## 死信的来源
消息TTL(Time to live[生存时间])过期
队列达到最大长度(队列满了 无法再添加数据到mq中)
消息被拒绝(basic.reject或者basic.nack) 并且requeue=false

## 死信的实现
 1 创建两个交换机 和 两个队列 分别为普通和死信
   - 在其中 创建两台交换机
     channel.exchangeDeclare(交换机名字,交换机类型);
     - 再创建队列 
      channel.queueDeclare("队列名",是否持久化,是否自动删除,是否..,更多配置);
       在多配置项中设置 map.put("x-dead-letter-exchange",死信交换机名）；
                     map.put("x-dead-letter-routing-key",死信队列的路由值);
        上述设置完毕后 该交换机的失败消息都会转发到死信交换机的对应的routingKey队列中
       - 创建死信队列
       - 绑定队列与交换机
           channel.queueBind(队列名,交换机,路由key);
         - 监听成功消息
    

## 死信的提供者实现
 -- 主要设置过期的时长
 //        设置过期时间
 AMQP.BasicProperties basicProperties =new AMQP.BasicProperties().builder().expiration("10000").build();

        for (int i = 0; i <11 ; i++) {
//                                设置消息过期时间
channel.basicPublish(ex,"normal",basicProperties,new String("当前的消息"+i).getBytes());
}

## 设置队列长度 同样的在创建队列时设置
map.put("x-max-length",10); // 设置长度 
如果接收信息超过了长度 那就会转发给死信队列 
   

## 消息被拒绝  转发给死信
                   // 并且不能使用自动应答
                    //                                           拒绝消息后 是否放回队列 只有不放回队列 才会放入死信队列
channel.basicReject(消息标识(message.getEnvelope.getDeliveryTag()),false) 


## 延迟队列
 延迟队列 队列的内部是有序的 最重要的时 体现在它的延时属性上卖弄 延时队列中的元素是希望在指定的时间到了以后或之前取出和处理 简单来说 延时队列就是用来存放需要
在指定的时间内被处理的元素的队列 
 延迟队列使用场景
  1 订单在十分钟之内未支付则自动取消
  2 新创建的商铺 如果十天没有新产品 则自动发送消息提醒
  3 用户创建了三天了 没有登录过 则进行短信提醒
  4 用户发起了退款 如果三天没有得到处理 则通知运营人员处理

## 整合springboot
1 加入RabbitMq的依赖
2 在配置文件中 配置rabbitMQ的链接配置
 - 使用了springboot后 
   1 消费者代码中 不再有声明交换机的代码 只关心消费消息
        - 交换机的代码由一个@Configration类来处理
   
## 延迟队列的原理 
 通过利用ttl(x-message-ttl)属性 来做延时处理
 (普通队列 会立即获取到消息)
  并且绑定一个死信队列 在延时结束的时候会将消息发送给死信队列
 rabbitTemplate.convertAndSend(交换机,routingKey,【延迟时间 该参数是一个函数接口 可以使用lambda表达式】)

## 优化延迟队列
 之前的写法的缺点
  - 1 多一个延迟的时间 就要多创建一个ttl属性的队列
  
 优化
  1 创建一个队列 不用设置 ttl属性 只用设置 死信的配置
 2 通过请求获取 延迟时间然后调用 rabbitTemplate.coverAndSend()方法
 rabbitTemplate.convertAndSend("nor_exchange","q3",message, (message1)->{
 //            设置时长
 message1.getMessageProperties().setExpiration(ttl);
 return message1;
 });

## RabbitMq通过插件实现延时队列
 去官网上面 下载 rabbitmq_delayed_message_exchange插件
放在
/usr/lib/rabbitmq/lib/rabbitmq_server/plugins
然后
执行 rabbitmq-plugins enable rabbitmq_delayed_message_exchange

然后就可以在后台管理界面的新增交换机栏位中 看到 x-delayed-message选项

通过上述步骤后 延迟队列的任务就不是队列来实现了 而是交换机

提供者 -router-> 设置了延迟的交换机(过x秒放消息) --router-> 队列 -> 消费者

## 发布确认的高级
当交换机宕机的时候 通过一个缓存将用户的消息存储起来 防止代码丢失

 实现方法 
  - 通过实现一个函数式接口 
    RabbitTemplete.ConfirmCallback 内部有一个方法需要我们来实现这个方法
    并且要通过  @PostConstruct 注解来进行调用函数 
               函数内部 调用rabbittemplete.setConfirmCallback(当前实现类/this)；
    然后在提供者的发送方法的第四个参数中 放入一个 new CorrelationData(id:String);
    
    最后在spring配置文件中添加
    //开启发布确认
    spring.rabbitmq.publisher-confirm-type=correlated
    //消息发送失败 就会马上回退给生产者
    spring.rabbitmq.publisher-returns=true
    
   然后在实现类中 再去实现 RabbitTemplate.ReturnsCallback 的方法 来做到消息失败回退
   @Override
   public void returnedMessage(Message message, int replycode, String replaytxt, String exchange, String routingkey) {
            System.out.println("失败的消息"+new String(message.getBody())+"原因"+replaytxt+"交换机"+exchange+"路由"+routingkey);
   }
  然后接着将该接口的实现类 注入到rabbittemplte对象中 默认是回退给生产者
  
  也可以不退回给生产者而是退回给备份交换机
  备份交换机是一个FanOut类型的交换机 绑定两个队列 一个为备份对列 一个为报警队列 
  备份交换机创建完毕后 通过主交换机设置 属性("alternate-exchange",备份交换机名
或者
  return ExchangeBuilder.directExchange(Exchange).durable(true).alternate(BackUpExchange).build();
  
然后就可以通过备份交换机的消费者进行消费本次消息


## 优先级队列

使用优先级队列 每一条的消息都会携带一个key key的大小就是他们的优先级 优先级越大 越早被消费 范围为0-255

代码实现
1 在创建队列时 指定当前队列优先级最大值
QueueBuilder.maxPriority(100).build();
2 在发送消息时
Spring boot 方法 new MessagePostProcessor  通过message.getMessageProperties().setPriority(5); 来设置消息的优先级
无 Springboot 设置 AMQP.BasicProperties properties= new AMQP.BasicProperties().builder().setProiority().bulid()); // 来设置优先级
  channel.basicPulish("",routingKey,放入AMQP构建的对象,二进制的消息)

## 懒惰队列 
就是将队列的内容全部存在磁盘上 保证高可用性

## RabbitMq集群
1 前往 vi /etc/host 文件中 添加 ip 和 要起的别名
192.168.194.128 node0
192.168.194.129 node1
192.168.194.130 node2
192.168.194.131 node3
2 为了确保各个节点的cookie文件使用的是同一个值
 在主机上面设置                             //要设置的节点 
scp /var/lib/rabbitmq/.erlang.cookie root@node1: /var/lib/rabbitmq/.erlang.cookie
scp /var/lib/rabbitmq/.erlang.cookie root@node2: /var/lib/rabbitmq/.erlang.cookie
scp /var/lib/rabbitmq/.erlang.cookie root@node3: /var/lib/rabbitmq/.erlang.cookie
 通过scp远程复制 将文件同步

3 所有服务器执行 rabbitmq-server -detached

4 在子节点执行
rabbitmqctl stop_app // 关闭erlang和rabbitmq虚拟机
rabbitmqctl reset //重置
rabbitmqctl join_cluster rabbit@要加入的主机 //加入xxx主机 作为从机
rabbitmqctl start_app //启动服务

5 查看集群 rabbitmqctl cluster_status
6 重新设置账户 rabbitmqctl add_user 用户 密码
7 设置用户角色 rabbitmqctl set_user_tags 用户 administrator
8 设置权限 rabbitmqctl set_permissions -p / 用户 ".*" ".*" ".*"

直接删掉集群中的某个节点：
rabbitmqctl forget_cluster_node   node_name

## 镜像队列 
 如果一台rabbit宕机 如果没有镜像队列的机制 那么它的队列就会丢失 队列的消息就会丢失
 如果设置镜像队列 每一次创建队列 都会自动存放一份在其他服务器中
 如何设置? 
 在后台管理中设置
 1 admin选项
 2 name 任意
 3 Pattrn 匹配规则 一般为 ^mirror (标识将会备份队列名为mirror开头的队列)


## 明天复习
 延迟队列 通过springboot实现 (x-delayed-message) 交换机延迟
 消息确认  （实现rabbitTemplte内部的一个函数接口） spring.rabbitmq.publisher-confirm-type=correlated
 消息返回 (实现rabbitTemplte内部的一个函数接口 通过@PostConstractor注入) spring.rabbitmq.publisher-returns=true
 备份交换机 (通过在创建交换机时设置 .alternate("备份交换机名")) 备份交换机通常是一个FanOut类的交换机
 死信 在配置的时候设置 deadLetterExchange() 和 deadLetterRoutingKey() 并且要把死信队列 绑定 到死信交换机中
## rabbitmq开发步骤
  1 创建sprngboot工厂
  2 设置配置类 在里面配置 交换机 队列 以及绑定
  3 写提供者 通过controller实现 并且获取rabbitTemplate对象 调用其方法来实现发送
  4 写消费者 通过@RabbitListener(queue="要消费的队列") 注解 来获取消息 
 
